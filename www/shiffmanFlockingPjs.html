<!DOCTYPE html>
<html>
  <head>
    <title>Shiffman Flocking - Toxiclibs.js</title>
    <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Droid+Serif:400,700">
    <link rel="stylesheet" href="stylesheets/style.css">
    <script src="javascripts/vendor/prettify.js"></script>
    <script src="javascripts/config.js"></script>
    <script data-main="../main" src="javascripts/vendor/require.js"></script>
    <script src="javascripts/vendor/xrayquire.js"></script>
  </head>
  <body>
    <div id="example-container" class="pjs">
      <canvas id="myCanvas" data-processing-sources="javascripts/examples/shiffmanFlockingPjs.pde"></canvas>
    </div>
    <script src="javascripts/vendor/processing.js"></script>
    <script src="../../working_dir/build/toxiclibs.js"></script>
    <script type="application/processing" data-processing-target="myCanvas">
//#Flocking
//by [Daniel Shiffman](http://www.shiffman.net)
//created for The Nature of Code class, ITP, Spring 2009.
//Ported to toxiclibs by Karsten Schmidt</p>
//Demonstration of <a href="http://www.red3d.com/cwr/">Craig Reynolds' "Flocking" behavior</a><br/>
//**Rules:** Cohesion, Separation, Alignment
//
//**Usage:** Click mouse to add boids into the system

/*
 * Copyright (c) 2009 Daniel Shiffman
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * http://creativecommons.org/licenses/LGPL/2.1/
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 */
 
import toxi.geom.*;
import toxi.math.*;

Flock flock;

void setup() {
  size(600,300);
  flock = new Flock();
  // Add an initial set of boids into the system
  for (int i = 0; i < 70; i++) {
    flock.addBoid(new Boid(new Vec2D(width/2,height/2),3.0,0.05));
  }
  smooth();
}

void draw() {
  background(250);
  flock.run();
}

// Add a new boid into the System
void mousePressed() {
  flock.addBoid(new Boid(new Vec2D(mouseX,mouseY),2.0,0.05f));
}



// Boid class
// Methods for Separation, Cohesion, Alignment added


var Vec2D = toxi.geom.Vec2D;

class Boid {

  Vec2D loc;
  Vec2D vel;
  Vec2D acc;
  float r;
  float maxforce;
  float maxspeed;

  public Boid(Vec2D l, float ms, float mf) {
    loc=l;
    acc = new Vec2D();
    vel = Vec2D.randomVector();
    r = 2.0;
    maxspeed = ms;
    maxforce = mf;
  }

  void run(ArrayList boids) {
    flock(boids);
    update();
    borders();
    render();
  }

  // We accumulate a new acceleration each time based on three rules
  void flock(ArrayList boids) {
    Vec2D sep = separate(boids);   // Separation
    Vec2D ali = align(boids);      // Alignment
    Vec2D coh = cohesion(boids);   // Cohesion
    // Arbitrarily weight these forces
    sep.scaleSelf(1.5);
    ali.scaleSelf(1.0);
    coh.scaleSelf(1.0);
    // Add the force vectors to acceleration
    acc.addSelf(sep);
    acc.addSelf(ali);
    acc.addSelf(coh);
  }

  // Method to update location
  void update() {
    // Update velocity
    vel.addSelf(acc);
    // Limit speed
    vel.limit(maxspeed);
    loc.addSelf(vel);
    // Reset accelertion to 0 each cycle
    acc.clear();
  }

  void seek(Vec2D target) {
    acc.addSelf(steer(target,false));
  }

  void arrive(Vec2D target) {
    acc.addSelf(steer(target,true));
  }

  // A method that calculates a steering vector towards a target
  // Takes a second argument, if true, it slows down as it approaches the target
  Vec2D steer(Vec2D target, boolean slowdown) {
    Vec2D steer;  // The steering vector
    Vec2D desired = target.sub(loc);  // A vector pointing from the location to the target
    float d = desired.magnitude(); // Distance from the target is the magnitude of the vector
    // If the distance is greater than 0, calc steering (otherwise return zero vector)
    if (d > 0) {
      // Normalize desired
      desired.normalize();
      // Two options for desired vector magnitude (1 -- based on distance, 2 -- maxspeed)
      if (slowdown && d < 100.0f) desired.scaleSelf(maxspeed*d/100.0f); // This damping is somewhat arbitrary
      else desired.scaleSelf(maxspeed);
      // Steering = Desired minus Velocity
      steer = desired.sub(vel).limit(maxforce);  // Limit to maximum steering force
    } 
    else {
      steer = new Vec2D();
    }
    return steer;
  }

  void render() {
    // Draw a triangle rotated in the direction of velocity
    float theta = vel.heading() + radians(90);
    fill(175);
    stroke(0);
    pushMatrix();
    translate(loc.x,loc.y);
    rotate(theta);
    beginShape(TRIANGLES);
    vertex(0, -r*2);
    vertex(-r, r*2);
    vertex(r, r*2);
    endShape();
    popMatrix();
  }

  // Wraparound
  void borders() {
    if (loc.x < -r) loc.x = width+r;
    if (loc.y < -r) loc.y = height+r;
    if (loc.x > width+r) loc.x = -r;
    if (loc.y > height+r) loc.y = -r;
  }

  // Separation
  // Method checks for nearby boids and steers away
  Vec2D separate(ArrayList boids) {
    float desiredseparation = 25.0f;
    Vec2D steer = new Vec2D();
    int count = 0;
    // For every boid in the system, check if it's too close
    for (int i = 0 ; i < boids.size(); i++) {
      Boid other = (Boid) boids.get(i);
      float d = loc.distanceTo(other.loc);
      // If the distance is greater than 0 and less than an arbitrary amount (0 when you are yourself)
      if ((d > 0) && (d < desiredseparation)) {
        // Calculate vector pointing away from neighbor
        Vec2D diff = loc.sub(other.loc);
        diff.normalizeTo(1.0/d);
        steer.addSelf(diff);
        count++;            // Keep track of how many
      }
    }
    // Average -- divide by how many
    if (count > 0) {
      steer.scaleSelf(1.0/count);
    }

    // As long as the vector is greater than 0
    if (steer.magnitude() > 0) {
      // Implement Reynolds: Steering = Desired - Velocity
      steer.normalizeTo(maxspeed);
      steer.subSelf(vel);
      steer.limit(maxforce);
    }
    return steer;
  }

  // Alignment
  // For every nearby boid in the system, calculate the average velocity
  Vec2D align (ArrayList boids) {
    float neighbordist = 50.0;
    Vec2D steer = new Vec2D();
    int count = 0;
    for (int i = 0 ; i < boids.size(); i++) {
      Boid other = (Boid) boids.get(i);
      float d = loc.distanceTo(other.loc);
      if ((d > 0) && (d < neighbordist)) {
        steer.addSelf(other.vel);
        count++;
      }
    }
    if (count > 0) {
      steer.scaleSelf(1.0/count);
    }

    // As long as the vector is greater than 0
    if (steer.magnitude() > 0) {
      // Implement Reynolds: Steering = Desired - Velocity
      steer.normalizeTo(maxspeed);
      steer.subSelf(vel);
      steer.limit(maxforce);
    }
    return steer;
  }

  // Cohesion
  // For the average location (i.e. center) of all nearby boids, calculate steering vector towards that location
  Vec2D cohesion (ArrayList boids) {
    float neighbordist = 50.0;
    Vec2D sum = new Vec2D();   // Start with empty vector to accumulate all locations
    int count = 0;
    for (int i = 0 ; i < boids.size(); i++) {
      Boid other = (Boid) boids.get(i);
      float d = loc.distanceTo(other.loc);
      if ((d > 0) && (d < neighbordist)) {
        sum.addSelf(other.loc); // Add location
        count++;
      }
    }
    if (count > 0) {
      sum.scaleSelf(1.0/count);
      return steer(sum,false);  // Steer towards the location
    }
    return sum;
  }
}

// Flock class
// Does very little, simply manages the ArrayList of all the boids

class Flock {
  ArrayList boids; // An arraylist for all the boids

    Flock() {
    boids = new ArrayList(); // Initialize the arraylist
  }

  void run() {
    for (int i = 0; i < boids.size(); i++) {
      Boid b = (Boid) boids.get(i);  
      b.run(boids);  // Passing the entire list of boids to each boid individually
    }
  }

  void addBoid(Boid b) {
    boids.add(b);
  }
}






</script>
    <section id="waist">
      <nav id="navigation">
        <ul>
          <li class="home"><a href="./">Toxiclibs.js</a></li>
          <li class="examples"><a href="#">Examples</a></li>
          <li class="name">Shiffman Flocking</li>
        </ul>
      </nav>
    </section>
    <section id="pagelet"><div class="docco annotated-source">     <div class="background"></div>     <ul class="sections">                                <li id="section-1">             <div class="annotation">               <div class="pilwrap">                 <a class="pilcrow" href="#section-1">&#182;</a>               </div>                                        </div>                          <div class="content"><div class="highlight"><pre><span class="c1">//#Flocking</span>
<span class="c1">//by [Daniel Shiffman](http://www.shiffman.net)</span>
<span class="c1">//created for The Nature of Code class, ITP, Spring 2009.</span>
<span class="c1">//Ported to toxiclibs by Karsten Schmidt&lt;/p&gt;</span>
<span class="c1">//Demonstration of &lt;a href=&quot;http://www.red3d.com/cwr/&quot;&gt;Craig Reynolds&#39; &quot;Flocking&quot; behavior&lt;/a&gt;&lt;br/&gt;</span>
<span class="c1">//**Rules:** Cohesion, Separation, Alignment</span>
<span class="c1">//</span>
<span class="c1">//**Usage:** Click mouse to add boids into the system</span>

<span class="cm">/*</span>
<span class="cm"> * Copyright (c) 2009 Daniel Shiffman</span>
<span class="cm"> *</span>
<span class="cm"> * This library is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU Lesser General Public</span>
<span class="cm"> * License as published by the Free Software Foundation; either</span>
<span class="cm"> * version 2.1 of the License, or (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * http://creativecommons.org/licenses/LGPL/2.1/</span>
<span class="cm"> *</span>
<span class="cm"> * This library is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<span class="cm"> * Lesser General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU Lesser General Public</span>
<span class="cm"> * License along with this library; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA</span>
<span class="cm"> */</span>
 
<span class="kr">import</span> <span class="nx">toxi</span><span class="p">.</span><span class="nx">geom</span><span class="p">.</span><span class="o">*</span><span class="p">;</span>
<span class="kr">import</span> <span class="nx">toxi</span><span class="p">.</span><span class="nx">math</span><span class="p">.</span><span class="o">*</span><span class="p">;</span>

<span class="nx">Flock</span> <span class="nx">flock</span><span class="p">;</span>

<span class="k">void</span> <span class="nx">setup</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">size</span><span class="p">(</span><span class="mi">600</span><span class="p">,</span><span class="mi">300</span><span class="p">);</span>
  <span class="nx">flock</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Flock</span><span class="p">();</span>
  <span class="c1">// Add an initial set of boids into the system</span>
  <span class="k">for</span> <span class="p">(</span><span class="kr">int</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mi">70</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">flock</span><span class="p">.</span><span class="nx">addBoid</span><span class="p">(</span><span class="k">new</span> <span class="nx">Boid</span><span class="p">(</span><span class="k">new</span> <span class="nx">Vec2D</span><span class="p">(</span><span class="nx">width</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="nx">height</span><span class="o">/</span><span class="mi">2</span><span class="p">),</span><span class="mf">3.0</span><span class="p">,</span><span class="mf">0.05</span><span class="p">));</span>
  <span class="p">}</span>
  <span class="nx">smooth</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">void</span> <span class="nx">draw</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">background</span><span class="p">(</span><span class="mi">250</span><span class="p">);</span>
  <span class="nx">flock</span><span class="p">.</span><span class="nx">run</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// Add a new boid into the System</span>
<span class="k">void</span> <span class="nx">mousePressed</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">flock</span><span class="p">.</span><span class="nx">addBoid</span><span class="p">(</span><span class="k">new</span> <span class="nx">Boid</span><span class="p">(</span><span class="k">new</span> <span class="nx">Vec2D</span><span class="p">(</span><span class="nx">mouseX</span><span class="p">,</span><span class="nx">mouseY</span><span class="p">),</span><span class="mf">2.0</span><span class="p">,</span><span class="mf">0.05f</span><span class="p">));</span>
<span class="p">}</span>



<span class="c1">// Boid class</span>
<span class="c1">// Methods for Separation, Cohesion, Alignment added</span>


<span class="kd">var</span> <span class="nx">Vec2D</span> <span class="o">=</span> <span class="nx">toxi</span><span class="p">.</span><span class="nx">geom</span><span class="p">.</span><span class="nx">Vec2D</span><span class="p">;</span>

<span class="kr">class</span> <span class="nx">Boid</span> <span class="p">{</span>

  <span class="nx">Vec2D</span> <span class="nx">loc</span><span class="p">;</span>
  <span class="nx">Vec2D</span> <span class="nx">vel</span><span class="p">;</span>
  <span class="nx">Vec2D</span> <span class="nx">acc</span><span class="p">;</span>
  <span class="kr">float</span> <span class="nx">r</span><span class="p">;</span>
  <span class="kr">float</span> <span class="nx">maxforce</span><span class="p">;</span>
  <span class="kr">float</span> <span class="nx">maxspeed</span><span class="p">;</span>

  <span class="kr">public</span> <span class="nx">Boid</span><span class="p">(</span><span class="nx">Vec2D</span> <span class="nx">l</span><span class="p">,</span> <span class="kr">float</span> <span class="nx">ms</span><span class="p">,</span> <span class="kr">float</span> <span class="nx">mf</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">loc</span><span class="o">=</span><span class="nx">l</span><span class="p">;</span>
    <span class="nx">acc</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Vec2D</span><span class="p">();</span>
    <span class="nx">vel</span> <span class="o">=</span> <span class="nx">Vec2D</span><span class="p">.</span><span class="nx">randomVector</span><span class="p">();</span>
    <span class="nx">r</span> <span class="o">=</span> <span class="mf">2.0</span><span class="p">;</span>
    <span class="nx">maxspeed</span> <span class="o">=</span> <span class="nx">ms</span><span class="p">;</span>
    <span class="nx">maxforce</span> <span class="o">=</span> <span class="nx">mf</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">void</span> <span class="nx">run</span><span class="p">(</span><span class="nx">ArrayList</span> <span class="nx">boids</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">flock</span><span class="p">(</span><span class="nx">boids</span><span class="p">);</span>
    <span class="nx">update</span><span class="p">();</span>
    <span class="nx">borders</span><span class="p">();</span>
    <span class="nx">render</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="c1">// We accumulate a new acceleration each time based on three rules</span>
  <span class="k">void</span> <span class="nx">flock</span><span class="p">(</span><span class="nx">ArrayList</span> <span class="nx">boids</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">Vec2D</span> <span class="nx">sep</span> <span class="o">=</span> <span class="nx">separate</span><span class="p">(</span><span class="nx">boids</span><span class="p">);</span>   <span class="c1">// Separation</span>
    <span class="nx">Vec2D</span> <span class="nx">ali</span> <span class="o">=</span> <span class="nx">align</span><span class="p">(</span><span class="nx">boids</span><span class="p">);</span>      <span class="c1">// Alignment</span>
    <span class="nx">Vec2D</span> <span class="nx">coh</span> <span class="o">=</span> <span class="nx">cohesion</span><span class="p">(</span><span class="nx">boids</span><span class="p">);</span>   <span class="c1">// Cohesion</span>
    <span class="c1">// Arbitrarily weight these forces</span>
    <span class="nx">sep</span><span class="p">.</span><span class="nx">scaleSelf</span><span class="p">(</span><span class="mf">1.5</span><span class="p">);</span>
    <span class="nx">ali</span><span class="p">.</span><span class="nx">scaleSelf</span><span class="p">(</span><span class="mf">1.0</span><span class="p">);</span>
    <span class="nx">coh</span><span class="p">.</span><span class="nx">scaleSelf</span><span class="p">(</span><span class="mf">1.0</span><span class="p">);</span>
    <span class="c1">// Add the force vectors to acceleration</span>
    <span class="nx">acc</span><span class="p">.</span><span class="nx">addSelf</span><span class="p">(</span><span class="nx">sep</span><span class="p">);</span>
    <span class="nx">acc</span><span class="p">.</span><span class="nx">addSelf</span><span class="p">(</span><span class="nx">ali</span><span class="p">);</span>
    <span class="nx">acc</span><span class="p">.</span><span class="nx">addSelf</span><span class="p">(</span><span class="nx">coh</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// Method to update location</span>
  <span class="k">void</span> <span class="nx">update</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// Update velocity</span>
    <span class="nx">vel</span><span class="p">.</span><span class="nx">addSelf</span><span class="p">(</span><span class="nx">acc</span><span class="p">);</span>
    <span class="c1">// Limit speed</span>
    <span class="nx">vel</span><span class="p">.</span><span class="nx">limit</span><span class="p">(</span><span class="nx">maxspeed</span><span class="p">);</span>
    <span class="nx">loc</span><span class="p">.</span><span class="nx">addSelf</span><span class="p">(</span><span class="nx">vel</span><span class="p">);</span>
    <span class="c1">// Reset accelertion to 0 each cycle</span>
    <span class="nx">acc</span><span class="p">.</span><span class="nx">clear</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="k">void</span> <span class="nx">seek</span><span class="p">(</span><span class="nx">Vec2D</span> <span class="nx">target</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">acc</span><span class="p">.</span><span class="nx">addSelf</span><span class="p">(</span><span class="nx">steer</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span><span class="kc">false</span><span class="p">));</span>
  <span class="p">}</span>

  <span class="k">void</span> <span class="nx">arrive</span><span class="p">(</span><span class="nx">Vec2D</span> <span class="nx">target</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">acc</span><span class="p">.</span><span class="nx">addSelf</span><span class="p">(</span><span class="nx">steer</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span><span class="kc">true</span><span class="p">));</span>
  <span class="p">}</span>

  <span class="c1">// A method that calculates a steering vector towards a target</span>
  <span class="c1">// Takes a second argument, if true, it slows down as it approaches the target</span>
  <span class="nx">Vec2D</span> <span class="nx">steer</span><span class="p">(</span><span class="nx">Vec2D</span> <span class="nx">target</span><span class="p">,</span> <span class="kr">boolean</span> <span class="nx">slowdown</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">Vec2D</span> <span class="nx">steer</span><span class="p">;</span>  <span class="c1">// The steering vector</span>
    <span class="nx">Vec2D</span> <span class="nx">desired</span> <span class="o">=</span> <span class="nx">target</span><span class="p">.</span><span class="nx">sub</span><span class="p">(</span><span class="nx">loc</span><span class="p">);</span>  <span class="c1">// A vector pointing from the location to the target</span>
    <span class="kr">float</span> <span class="nx">d</span> <span class="o">=</span> <span class="nx">desired</span><span class="p">.</span><span class="nx">magnitude</span><span class="p">();</span> <span class="c1">// Distance from the target is the magnitude of the vector</span>
    <span class="c1">// If the distance is greater than 0, calc steering (otherwise return zero vector)</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">d</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// Normalize desired</span>
      <span class="nx">desired</span><span class="p">.</span><span class="nx">normalize</span><span class="p">();</span>
      <span class="c1">// Two options for desired vector magnitude (1 -- based on distance, 2 -- maxspeed)</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">slowdown</span> <span class="o">&amp;&amp;</span> <span class="nx">d</span> <span class="o">&lt;</span> <span class="mf">100.0f</span><span class="p">)</span> <span class="nx">desired</span><span class="p">.</span><span class="nx">scaleSelf</span><span class="p">(</span><span class="nx">maxspeed</span><span class="o">*</span><span class="nx">d</span><span class="o">/</span><span class="mf">100.0f</span><span class="p">);</span> <span class="c1">// This damping is somewhat arbitrary</span>
      <span class="k">else</span> <span class="nx">desired</span><span class="p">.</span><span class="nx">scaleSelf</span><span class="p">(</span><span class="nx">maxspeed</span><span class="p">);</span>
      <span class="c1">// Steering = Desired minus Velocity</span>
      <span class="nx">steer</span> <span class="o">=</span> <span class="nx">desired</span><span class="p">.</span><span class="nx">sub</span><span class="p">(</span><span class="nx">vel</span><span class="p">).</span><span class="nx">limit</span><span class="p">(</span><span class="nx">maxforce</span><span class="p">);</span>  <span class="c1">// Limit to maximum steering force</span>
    <span class="p">}</span> 
    <span class="k">else</span> <span class="p">{</span>
      <span class="nx">steer</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Vec2D</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">steer</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">void</span> <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// Draw a triangle rotated in the direction of velocity</span>
    <span class="kr">float</span> <span class="nx">theta</span> <span class="o">=</span> <span class="nx">vel</span><span class="p">.</span><span class="nx">heading</span><span class="p">()</span> <span class="o">+</span> <span class="nx">radians</span><span class="p">(</span><span class="mi">90</span><span class="p">);</span>
    <span class="nx">fill</span><span class="p">(</span><span class="mi">175</span><span class="p">);</span>
    <span class="nx">stroke</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="nx">pushMatrix</span><span class="p">();</span>
    <span class="nx">translate</span><span class="p">(</span><span class="nx">loc</span><span class="p">.</span><span class="nx">x</span><span class="p">,</span><span class="nx">loc</span><span class="p">.</span><span class="nx">y</span><span class="p">);</span>
    <span class="nx">rotate</span><span class="p">(</span><span class="nx">theta</span><span class="p">);</span>
    <span class="nx">beginShape</span><span class="p">(</span><span class="nx">TRIANGLES</span><span class="p">);</span>
    <span class="nx">vertex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="nx">r</span><span class="o">*</span><span class="mi">2</span><span class="p">);</span>
    <span class="nx">vertex</span><span class="p">(</span><span class="o">-</span><span class="nx">r</span><span class="p">,</span> <span class="nx">r</span><span class="o">*</span><span class="mi">2</span><span class="p">);</span>
    <span class="nx">vertex</span><span class="p">(</span><span class="nx">r</span><span class="p">,</span> <span class="nx">r</span><span class="o">*</span><span class="mi">2</span><span class="p">);</span>
    <span class="nx">endShape</span><span class="p">();</span>
    <span class="nx">popMatrix</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="c1">// Wraparound</span>
  <span class="k">void</span> <span class="nx">borders</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">loc</span><span class="p">.</span><span class="nx">x</span> <span class="o">&lt;</span> <span class="o">-</span><span class="nx">r</span><span class="p">)</span> <span class="nx">loc</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="nx">width</span><span class="o">+</span><span class="nx">r</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">loc</span><span class="p">.</span><span class="nx">y</span> <span class="o">&lt;</span> <span class="o">-</span><span class="nx">r</span><span class="p">)</span> <span class="nx">loc</span><span class="p">.</span><span class="nx">y</span> <span class="o">=</span> <span class="nx">height</span><span class="o">+</span><span class="nx">r</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">loc</span><span class="p">.</span><span class="nx">x</span> <span class="o">&gt;</span> <span class="nx">width</span><span class="o">+</span><span class="nx">r</span><span class="p">)</span> <span class="nx">loc</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="o">-</span><span class="nx">r</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">loc</span><span class="p">.</span><span class="nx">y</span> <span class="o">&gt;</span> <span class="nx">height</span><span class="o">+</span><span class="nx">r</span><span class="p">)</span> <span class="nx">loc</span><span class="p">.</span><span class="nx">y</span> <span class="o">=</span> <span class="o">-</span><span class="nx">r</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// Separation</span>
  <span class="c1">// Method checks for nearby boids and steers away</span>
  <span class="nx">Vec2D</span> <span class="nx">separate</span><span class="p">(</span><span class="nx">ArrayList</span> <span class="nx">boids</span><span class="p">)</span> <span class="p">{</span>
    <span class="kr">float</span> <span class="nx">desiredseparation</span> <span class="o">=</span> <span class="mf">25.0f</span><span class="p">;</span>
    <span class="nx">Vec2D</span> <span class="nx">steer</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Vec2D</span><span class="p">();</span>
    <span class="kr">int</span> <span class="nx">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="c1">// For every boid in the system, check if it&#39;s too close</span>
    <span class="k">for</span> <span class="p">(</span><span class="kr">int</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">boids</span><span class="p">.</span><span class="nx">size</span><span class="p">();</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">Boid</span> <span class="nx">other</span> <span class="o">=</span> <span class="p">(</span><span class="nx">Boid</span><span class="p">)</span> <span class="nx">boids</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span>
      <span class="kr">float</span> <span class="nx">d</span> <span class="o">=</span> <span class="nx">loc</span><span class="p">.</span><span class="nx">distanceTo</span><span class="p">(</span><span class="nx">other</span><span class="p">.</span><span class="nx">loc</span><span class="p">);</span>
      <span class="c1">// If the distance is greater than 0 and less than an arbitrary amount (0 when you are yourself)</span>
      <span class="k">if</span> <span class="p">((</span><span class="nx">d</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">d</span> <span class="o">&lt;</span> <span class="nx">desiredseparation</span><span class="p">))</span> <span class="p">{</span>
        <span class="c1">// Calculate vector pointing away from neighbor</span>
        <span class="nx">Vec2D</span> <span class="nx">diff</span> <span class="o">=</span> <span class="nx">loc</span><span class="p">.</span><span class="nx">sub</span><span class="p">(</span><span class="nx">other</span><span class="p">.</span><span class="nx">loc</span><span class="p">);</span>
        <span class="nx">diff</span><span class="p">.</span><span class="nx">normalizeTo</span><span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="nx">d</span><span class="p">);</span>
        <span class="nx">steer</span><span class="p">.</span><span class="nx">addSelf</span><span class="p">(</span><span class="nx">diff</span><span class="p">);</span>
        <span class="nx">count</span><span class="o">++</span><span class="p">;</span>            <span class="c1">// Keep track of how many</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// Average -- divide by how many</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">steer</span><span class="p">.</span><span class="nx">scaleSelf</span><span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="nx">count</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// As long as the vector is greater than 0</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">steer</span><span class="p">.</span><span class="nx">magnitude</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// Implement Reynolds: Steering = Desired - Velocity</span>
      <span class="nx">steer</span><span class="p">.</span><span class="nx">normalizeTo</span><span class="p">(</span><span class="nx">maxspeed</span><span class="p">);</span>
      <span class="nx">steer</span><span class="p">.</span><span class="nx">subSelf</span><span class="p">(</span><span class="nx">vel</span><span class="p">);</span>
      <span class="nx">steer</span><span class="p">.</span><span class="nx">limit</span><span class="p">(</span><span class="nx">maxforce</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">steer</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// Alignment</span>
  <span class="c1">// For every nearby boid in the system, calculate the average velocity</span>
  <span class="nx">Vec2D</span> <span class="nx">align</span> <span class="p">(</span><span class="nx">ArrayList</span> <span class="nx">boids</span><span class="p">)</span> <span class="p">{</span>
    <span class="kr">float</span> <span class="nx">neighbordist</span> <span class="o">=</span> <span class="mf">50.0</span><span class="p">;</span>
    <span class="nx">Vec2D</span> <span class="nx">steer</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Vec2D</span><span class="p">();</span>
    <span class="kr">int</span> <span class="nx">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kr">int</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">boids</span><span class="p">.</span><span class="nx">size</span><span class="p">();</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">Boid</span> <span class="nx">other</span> <span class="o">=</span> <span class="p">(</span><span class="nx">Boid</span><span class="p">)</span> <span class="nx">boids</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span>
      <span class="kr">float</span> <span class="nx">d</span> <span class="o">=</span> <span class="nx">loc</span><span class="p">.</span><span class="nx">distanceTo</span><span class="p">(</span><span class="nx">other</span><span class="p">.</span><span class="nx">loc</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">((</span><span class="nx">d</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">d</span> <span class="o">&lt;</span> <span class="nx">neighbordist</span><span class="p">))</span> <span class="p">{</span>
        <span class="nx">steer</span><span class="p">.</span><span class="nx">addSelf</span><span class="p">(</span><span class="nx">other</span><span class="p">.</span><span class="nx">vel</span><span class="p">);</span>
        <span class="nx">count</span><span class="o">++</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">steer</span><span class="p">.</span><span class="nx">scaleSelf</span><span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="nx">count</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// As long as the vector is greater than 0</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">steer</span><span class="p">.</span><span class="nx">magnitude</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// Implement Reynolds: Steering = Desired - Velocity</span>
      <span class="nx">steer</span><span class="p">.</span><span class="nx">normalizeTo</span><span class="p">(</span><span class="nx">maxspeed</span><span class="p">);</span>
      <span class="nx">steer</span><span class="p">.</span><span class="nx">subSelf</span><span class="p">(</span><span class="nx">vel</span><span class="p">);</span>
      <span class="nx">steer</span><span class="p">.</span><span class="nx">limit</span><span class="p">(</span><span class="nx">maxforce</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">steer</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// Cohesion</span>
  <span class="c1">// For the average location (i.e. center) of all nearby boids, calculate steering vector towards that location</span>
  <span class="nx">Vec2D</span> <span class="nx">cohesion</span> <span class="p">(</span><span class="nx">ArrayList</span> <span class="nx">boids</span><span class="p">)</span> <span class="p">{</span>
    <span class="kr">float</span> <span class="nx">neighbordist</span> <span class="o">=</span> <span class="mf">50.0</span><span class="p">;</span>
    <span class="nx">Vec2D</span> <span class="nx">sum</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Vec2D</span><span class="p">();</span>   <span class="c1">// Start with empty vector to accumulate all locations</span>
    <span class="kr">int</span> <span class="nx">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kr">int</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">boids</span><span class="p">.</span><span class="nx">size</span><span class="p">();</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">Boid</span> <span class="nx">other</span> <span class="o">=</span> <span class="p">(</span><span class="nx">Boid</span><span class="p">)</span> <span class="nx">boids</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span>
      <span class="kr">float</span> <span class="nx">d</span> <span class="o">=</span> <span class="nx">loc</span><span class="p">.</span><span class="nx">distanceTo</span><span class="p">(</span><span class="nx">other</span><span class="p">.</span><span class="nx">loc</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">((</span><span class="nx">d</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">d</span> <span class="o">&lt;</span> <span class="nx">neighbordist</span><span class="p">))</span> <span class="p">{</span>
        <span class="nx">sum</span><span class="p">.</span><span class="nx">addSelf</span><span class="p">(</span><span class="nx">other</span><span class="p">.</span><span class="nx">loc</span><span class="p">);</span> <span class="c1">// Add location</span>
        <span class="nx">count</span><span class="o">++</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">sum</span><span class="p">.</span><span class="nx">scaleSelf</span><span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="nx">count</span><span class="p">);</span>
      <span class="k">return</span> <span class="nx">steer</span><span class="p">(</span><span class="nx">sum</span><span class="p">,</span><span class="kc">false</span><span class="p">);</span>  <span class="c1">// Steer towards the location</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">sum</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Flock class</span>
<span class="c1">// Does very little, simply manages the ArrayList of all the boids</span>

<span class="kr">class</span> <span class="nx">Flock</span> <span class="p">{</span>
  <span class="nx">ArrayList</span> <span class="nx">boids</span><span class="p">;</span> <span class="c1">// An arraylist for all the boids</span>

    <span class="nx">Flock</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">boids</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">ArrayList</span><span class="p">();</span> <span class="c1">// Initialize the arraylist</span>
  <span class="p">}</span>

  <span class="k">void</span> <span class="nx">run</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kr">int</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">boids</span><span class="p">.</span><span class="nx">size</span><span class="p">();</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">Boid</span> <span class="nx">b</span> <span class="o">=</span> <span class="p">(</span><span class="nx">Boid</span><span class="p">)</span> <span class="nx">boids</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span>  
      <span class="nx">b</span><span class="p">.</span><span class="nx">run</span><span class="p">(</span><span class="nx">boids</span><span class="p">);</span>  <span class="c1">// Passing the entire list of boids to each boid individually</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">void</span> <span class="nx">addBoid</span><span class="p">(</span><span class="nx">Boid</span> <span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">boids</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">b</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

</pre></div></div>                      </li>              </ul>  </div> </section>
    <footer></footer>
  </body>
</html>